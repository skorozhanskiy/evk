/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/js/app.js":
/*!***********************!*\
  !*** ./src/js/app.js ***!
  \***********************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _modules_isWebp_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./modules/isWebp.js */ \"./src/js/modules/isWebp.js\");\n/* harmony import */ var _modules_burger_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./modules/burger.js */ \"./src/js/modules/burger.js\");\n/* harmony import */ var _modules_search_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./modules/search.js */ \"./src/js/modules/search.js\");\n/* harmony import */ var _modules_accordion_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./modules/accordion.js */ \"./src/js/modules/accordion.js\");\n/* harmony import */ var _modules_tabs_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./modules/tabs.js */ \"./src/js/modules/tabs.js\");\n/* harmony import */ var _modules_slider_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./modules/slider.js */ \"./src/js/modules/slider.js\");\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nwindow.addEventListener('DOMContentLoaded', function () {\r\n  (0,_modules_burger_js__WEBPACK_IMPORTED_MODULE_1__.menuActive)();\r\n  (0,_modules_search_js__WEBPACK_IMPORTED_MODULE_2__.searchActive)();\r\n\r\n  _modules_isWebp_js__WEBPACK_IMPORTED_MODULE_0__.isWebp();\r\n});\r\n\n\n//# sourceURL=webpack://evclid-nav/./src/js/app.js?");

/***/ }),

/***/ "./src/js/modules/accordion.js":
/*!*************************************!*\
  !*** ./src/js/modules/accordion.js ***!
  \*************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ItcAccordion\": () => (/* binding */ ItcAccordion)\n/* harmony export */ });\nwindow.addEventListener('DOMContentLoaded', function () {\r\n  new ItcAccordion(document.querySelector('.accordion'), {\r\n    alwaysOpen: false,\r\n  });\r\n});\r\n\r\nclass ItcAccordion {\r\n  constructor(target, config) {\r\n    this._el = typeof target === 'string' ? document.querySelector(target) : target;\r\n    const defaultConfig = {\r\n      alwaysOpen: true,\r\n      duration: 350,\r\n    };\r\n    this._config = Object.assign(defaultConfig, config);\r\n    this._el.querySelectorAll('.accordion__body').forEach((element) => {\r\n      element.style.transition = `max-height ${this._config.duration}ms ease-out`;\r\n    });\r\n    this.addEventListener();\r\n  }\r\n  addEventListener() {\r\n    this._el.addEventListener('click', (e) => {\r\n      const elHeader = e.target.closest('.accordion__button');\r\n      if (!elHeader) {\r\n        return;\r\n      }\r\n      if (!this._config.alwaysOpen) {\r\n        const elOpenItem = this._el.querySelector('.accordion__item_show');\r\n        if (elOpenItem) {\r\n          elOpenItem !== elHeader.parentElement ? this.toggle(elOpenItem) : null;\r\n        }\r\n      }\r\n      this.toggle(elHeader.parentElement);\r\n    });\r\n  }\r\n  toggle(el) {\r\n    el.classList.toggle('accordion__item_show');\r\n    const accordionBody = el.querySelector('.accordion__body');\r\n    if (accordionBody.style.maxHeight) {\r\n      accordionBody.style.maxHeight = null;\r\n    } else {\r\n      accordionBody.style.maxHeight = `${accordionBody.scrollHeight}px`;\r\n    }\r\n  }\r\n}\r\n\n\n//# sourceURL=webpack://evclid-nav/./src/js/modules/accordion.js?");

/***/ }),

/***/ "./src/js/modules/burger.js":
/*!**********************************!*\
  !*** ./src/js/modules/burger.js ***!
  \**********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"menuActive\": () => (/* binding */ menuActive)\n/* harmony export */ });\nconst menuActive = () => {\r\n  //отслеживаем клик по экрану сайта\r\n  window.addEventListener('click', function (click) {\r\n    //Если клик был произведен на блок у которого есть родительский элемент с классом .burger..\r\n    if (click.target.closest('.header__button-burger')) {\r\n      //..тогда создаем переменную, которая содержит иконку меню..\r\n      const menyIcon = document.querySelector('.header__button-burger');\r\n      const navOpen = document.querySelector('.header__nav');\r\n      //..и потом мы добавляем модификатор --active к иконки меню\r\n      menyIcon.classList.toggle('active');\r\n      navOpen.classList.toggle('active');\r\n      //отменяем классы при нажатии на ссылку\r\n      navOpen.addEventListener('click', function (close) {\r\n        if (close.target.matches('a')) {\r\n          navOpen.classList.remove('active');\r\n          menyIcon.classList.remove('active');\r\n        }\r\n      });\r\n    }\r\n  });\r\n};\r\n\n\n//# sourceURL=webpack://evclid-nav/./src/js/modules/burger.js?");

/***/ }),

/***/ "./src/js/modules/isWebp.js":
/*!**********************************!*\
  !*** ./src/js/modules/isWebp.js ***!
  \**********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"isWebp\": () => (/* binding */ isWebp)\n/* harmony export */ });\n/* Проверка поддержки webp, добавления webp или no-webp для HTML*/\r\nfunction isWebp() {\r\n\t// Проверка поддержки webp\r\n\tfunction testWebP(callback) {\r\n\t\tlet webP = new Image();\r\n\t\twebP.onload = webP.onerror = function () {\r\n\t\t\tcallback(webP.height == 2);\r\n\t\t};\r\n\t\twebP.src = \"data:image/webp;base64,UklGRjoAAABXRUJQVlA4IC4AAACyAgCdASoCAAIALmk0mk0iIiIiIgBoSygABc6WWgAA/veff/0PP8bA//LwYAAA\"\r\n\t}\r\n\t//Добавление класса _webp или _no-webp для  HTML\r\n\ttestWebP(function (support) {\r\n\t\tlet className = support === true ? 'webp' : 'no-webp';\r\n\t\tdocument.documentElement.classList.add(className);\r\n\t})\r\n}\n\n//# sourceURL=webpack://evclid-nav/./src/js/modules/isWebp.js?");

/***/ }),

/***/ "./src/js/modules/search.js":
/*!**********************************!*\
  !*** ./src/js/modules/search.js ***!
  \**********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"searchActive\": () => (/* binding */ searchActive)\n/* harmony export */ });\nconst searchActive = () => {\r\n  //отслеживаем клик по экрану сайта\r\n  window.addEventListener('click', function (click) {\r\n    //Если клик был произведен на блок у которого есть родительский элемент с классом .burger..\r\n    if (click.target.closest('.open-search')) {\r\n      //..тогда создаем переменную, которая содержит иконку меню..\r\n      // const searchIcon = document.querySelector('.header__button-search');\r\n      const searchOpen = document.querySelector('.search__container');\r\n      //..и потом мы добавляем модификатор --active к иконки меню\r\n      // searchIcon.classList.toggle('search__active');\r\n      searchOpen.classList.toggle('search__active');\r\n      //отменяем классы при нажатии на ссылку\r\n      // navOpen.addEventListener('click', function (close) {\r\n      //   if (close.target.matches('a')) {\r\n      //     navOpen.classList.remove('active');\r\n      //     menyIcon.classList.remove('active');\r\n      //   }\r\n      // });\r\n    }\r\n  });\r\n};\r\n\n\n//# sourceURL=webpack://evclid-nav/./src/js/modules/search.js?");

/***/ }),

/***/ "./src/js/modules/slider.js":
/*!**********************************!*\
  !*** ./src/js/modules/slider.js ***!
  \**********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ItcSlider\": () => (/* binding */ ItcSlider)\n/* harmony export */ });\n/**\r\n * @class ItcSlider\r\n * @version 1.0.1\r\n * @author https://github.com/itchief\r\n * @copyright Alexander Maltsev 2020 - 2023\r\n * @license MIT (https://github.com/itchief/ui-components/blob/master/LICENSE)\r\n * @tutorial https://itchief.ru/javascript/slider\r\n */\r\n\r\nclass ItcSlider {\r\n  static #EL_WRAPPER = 'wrapper';\r\n  static #EL_ITEMS = 'items';\r\n  static #EL_ITEM = 'item';\r\n  static #EL_ITEM_ACTIVE = 'item-active';\r\n  static #EL_INDICATOR = 'indicator';\r\n  static #EL_INDICATOR_ACTIVE = 'indicator-active';\r\n  static #BTN_PREV = 'btn-prev';\r\n  static #BTN_NEXT = 'btn-next';\r\n  static #BTN_HIDE = 'btn-hide';\r\n  static #TRANSITION_NONE = 'transition-none';\r\n  static #SWIPE_THRESHOLD = 20;\r\n\r\n  static #instances = [];\r\n\r\n  static checkSupportPassiveEvents() {\r\n    let passiveSupported = false;\r\n    try {\r\n      const options = Object.defineProperty({}, 'passive', {\r\n        get() {\r\n          passiveSupported = true;\r\n        },\r\n      });\r\n      window.addEventListener('testPassiveListener', null, options);\r\n      window.removeEventListener('testPassiveListener', null, options);\r\n    } catch (error) {\r\n      passiveSupported = false;\r\n    }\r\n    return passiveSupported;\r\n  }\r\n\r\n  #config;\r\n  #state;\r\n\r\n  /**\r\n   * @param {HTMLElement} el\r\n   * @param {Object} config\r\n   * @param {String} prefix\r\n   */\r\n  constructor(el, config = {}, prefix = 'itc-slider-') {\r\n    this.#state = {\r\n      prefix, // префикс для классов\r\n      el, // элемент который нужно активировать как ItcSlider\r\n      elWrapper: el.querySelector(`.${prefix}${this.constructor.#EL_WRAPPER}`), // элемент с #CLASS_WRAPPER\r\n      elItems: el.querySelector(`.${prefix}${this.constructor.#EL_ITEMS}`), // элемент, в котором находятся слайды\r\n      elListItem: el.querySelectorAll(`.${prefix}${this.constructor.#EL_ITEM}`), // список элементов, являющиеся слайдами\r\n      btnPrev: el.querySelector(`.${prefix}${this.constructor.#BTN_PREV}`), // кнопка, для перехода к предыдущему слайду\r\n      btnNext: el.querySelector(`.${prefix}${this.constructor.#BTN_NEXT}`), // кнопка, для перехода к следующему слайду\r\n      btnClassHide: prefix + this.constructor.#BTN_HIDE, // класс для скрытия кнопки\r\n      exOrderMin: 0,\r\n      exOrderMax: 0,\r\n      exItemMin: null,\r\n      exItemMax: null,\r\n      exTranslateMin: 0,\r\n      exTranslateMax: 0,\r\n      direction: 'next', // направление смены слайдов\r\n      intervalId: null, // id таймера\r\n      isSwiping: false,\r\n      swipeX: 0,\r\n      swipeY: 0,\r\n    };\r\n\r\n    this.#config = {\r\n      loop: true,\r\n      direction: 'next',\r\n      autoplay: false,\r\n      interval: 5000,\r\n      refresh: true,\r\n      swipe: true,\r\n      ...config,\r\n    };\r\n\r\n    this.#init();\r\n    this.#attachEvents();\r\n  }\r\n\r\n  /**\r\n   * Статический метод, который возвращает экземпляр ItcSlider, связанный с DOM-элементом\r\n   * @param {HTMLElement} elSlider\r\n   * @returns {?ItcSlider}\r\n   */\r\n  static getInstance(elSlider) {\r\n    const found = this.#instances.find((el) => el.target === elSlider);\r\n    if (found) {\r\n      return found.instance;\r\n    }\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * @param {String|HTMLElement} target\r\n   * @param {Object} config\r\n   * @param {String} prefix\r\n   */\r\n  static getOrCreateInstance(target, config = {}, prefix = 'itc-slider-') {\r\n    const elSlider = typeof target === 'string' ? document.querySelector(target) : target;\r\n    const result = this.getInstance(elSlider);\r\n    if (result) {\r\n      return result;\r\n    }\r\n    const slider = new this(elSlider, config, prefix);\r\n    this.#instances.push({ target: elSlider, instance: slider });\r\n    return slider;\r\n  }\r\n\r\n  // статический метод для активирования элементов как ItcSlider на основе data-атрибутов\r\n  static createInstances() {\r\n    document.querySelectorAll('[data-slider=\"itc-slider\"]').forEach((el) => {\r\n      const { dataset } = el;\r\n      const params = {};\r\n      Object.keys(dataset).forEach((key) => {\r\n        if (key === 'slider') {\r\n          return;\r\n        }\r\n        let value = dataset[key];\r\n        value = Number.isNaN(Number(value)) ? value : Number(value);\r\n        value = value === 'true' ? true : value;\r\n        value = value === 'false' ? false : value;\r\n        params[key] = value;\r\n      });\r\n      this.getOrCreateInstance(el, params);\r\n    });\r\n  }\r\n\r\n  slideNext() {\r\n    this.#state.direction = 'next';\r\n    this.#move();\r\n  }\r\n\r\n  slidePrev() {\r\n    this.#state.direction = 'prev';\r\n    this.#move();\r\n  }\r\n\r\n  slideTo(index) {\r\n    this.#moveTo(index);\r\n  }\r\n\r\n  reset() {\r\n    this.#reset();\r\n  }\r\n\r\n  get autoplay() {\r\n    return {\r\n      // Start autoplay\r\n      start: () => {\r\n        this.#config.autoplay = true;\r\n        this.#autoplay();\r\n      },\r\n      // Stop autoplay\r\n      stop: () => {\r\n        this.#autoplay('stop');\r\n        this.#config.autoplay = false;\r\n      },\r\n    };\r\n  }\r\n\r\n  dispose() {\r\n    this.#detachEvents();\r\n    const transitionNoneClass = this.#state.prefix + this.constructor.#TRANSITION_NONE;\r\n    const activeClass = this.#state.prefix + this.constructor.#EL_ITEM_ACTIVE;\r\n    this.#autoplay('stop');\r\n    this.#state.elItems.classList.add(transitionNoneClass);\r\n    this.#state.elItems.style.transform = '';\r\n    this.#state.elListItem.forEach((el) => {\r\n      el.style.transform = '';\r\n      el.classList.remove(activeClass);\r\n    });\r\n    const selIndicators = `${this.#state.prefix}${this.constructor.#EL_INDICATOR_ACTIVE}`;\r\n    document.querySelectorAll(`.${selIndicators}`).forEach((el) => {\r\n      el.classList.remove(selIndicators);\r\n    });\r\n    this.#state.elItems.offsetHeight;\r\n    this.#state.elItems.classList.remove(transitionNoneClass);\r\n    const index = this.constructor.#instances.findIndex((el) => el.target === this.#state.el);\r\n    this.constructor.#instances.splice(index, 1);\r\n  }\r\n\r\n  #onClick(e) {\r\n    if (this.#state.isMoving) {\r\n      e.preventDefault();\r\n    }\r\n    if (!(e.target.closest('.itc-slider-btn') || e.target.closest('.itc-slider-indicators'))) {\r\n      return;\r\n    }\r\n    const classBtnPrev = this.#state.prefix + this.constructor.#BTN_PREV;\r\n    const classBtnNext = this.#state.prefix + this.constructor.#BTN_NEXT;\r\n    this.#autoplay('stop');\r\n    if (e.target.closest(`.${classBtnPrev}`) || e.target.closest(`.${classBtnNext}`)) {\r\n      this.#state.direction = e.target.closest(`.${classBtnPrev}`) ? 'prev' : 'next';\r\n      this.#move();\r\n    } else if (e.target.dataset.slideTo) {\r\n      const index = parseInt(e.target.dataset.slideTo, 10);\r\n      this.#moveTo(index);\r\n    }\r\n    this.#config.loop ? this.#autoplay() : null;\r\n  }\r\n\r\n  #onMouseEnter() {\r\n    this.#autoplay('stop');\r\n  }\r\n\r\n  #onMouseLeave() {\r\n    this.#autoplay();\r\n  }\r\n\r\n  #onTransitionStart() {\r\n    if (this.#config.loop) {\r\n      if (this.#state.isBalancing) {\r\n        return;\r\n      }\r\n      this.#state.isBalancing = true;\r\n      window.requestAnimationFrame(() => {\r\n        this.#balanceItems(false);\r\n      });\r\n    }\r\n  }\r\n\r\n  #onTransitionEnd() {\r\n    if (this.#config.loop) {\r\n      this.#state.isBalancing = false;\r\n    }\r\n  }\r\n\r\n  #onDragStart(e) {\r\n    e.preventDefault();\r\n  }\r\n\r\n  #onVisibilityChange() {\r\n    if (document.visibilityState === 'hidden') {\r\n      this.#autoplay('stop');\r\n    } else if (document.visibilityState === 'visible' && this.#config.loop) {\r\n      this.#autoplay();\r\n    }\r\n  }\r\n\r\n  #touchStart(e) {\r\n    this.#state.isMoving = false;\r\n    this.#autoplay('stop');\r\n    const event = e.type.search('touch') === 0 ? e.touches[0] : e;\r\n    this.#state.swipeX = event.clientX;\r\n    this.#state.swipeY = event.clientY;\r\n    this.#state.isSwiping = true;\r\n    this.#state.isTouchMoving = false;\r\n  }\r\n\r\n  #touchEnd(e) {\r\n    if (!this.#state.isSwiping) {\r\n      return;\r\n    }\r\n    const event = e.type.search('touch') === 0 ? e.changedTouches[0] : e;\r\n    const wrapperRect = this.#state.elWrapper.getBoundingClientRect();\r\n    let clientX = event.clientX < wrapperRect.left ? wrapperRect.left : event.clientX;\r\n    clientX = clientX > wrapperRect.right ? wrapperRect.right : clientX;\r\n    let diffPosX = this.#state.swipeX - clientX;\r\n    if (diffPosX === 0) {\r\n      this.#state.isSwiping = false;\r\n      return;\r\n    }\r\n    if (!this.#config.loop) {\r\n      const isNotMoveFirst = this.#state.activeItems[0] === 1 && diffPosX <= 0;\r\n      const isNotMoveLast =\r\n        this.#state.activeItems[this.#state.activeItems.length - 1] && diffPosX >= 0;\r\n      if (isNotMoveFirst || isNotMoveLast) {\r\n        diffPosX = 0;\r\n      }\r\n    }\r\n    const value = (diffPosX / this.#state.width) * 100;\r\n    const transitionNoneClass = this.#state.prefix + this.constructor.#TRANSITION_NONE;\r\n    this.#state.elItems.classList.remove(transitionNoneClass);\r\n    if (value > this.constructor.#SWIPE_THRESHOLD) {\r\n      this.#state.direction = 'next';\r\n      let count = 0;\r\n      while (count <= Math.floor(Math.abs(value) - this.constructor.#SWIPE_THRESHOLD) / 100) {\r\n        this.#move();\r\n        count += 1;\r\n      }\r\n    } else if (value < -this.constructor.#SWIPE_THRESHOLD) {\r\n      this.#state.direction = 'prev';\r\n      let count = 0;\r\n      while (count <= Math.floor(Math.abs(value) - this.constructor.#SWIPE_THRESHOLD) / 100) {\r\n        this.#move();\r\n        count += 1;\r\n      }\r\n    } else {\r\n      this.#state.direction = 'none';\r\n      this.#move();\r\n    }\r\n    this.#state.isSwiping = false;\r\n    if (this.#config.loop) {\r\n      this.#autoplay();\r\n    }\r\n    this.#state.isBalancing = false;\r\n  }\r\n\r\n  #touchMove(e) {\r\n    if (!this.#state.isSwiping) {\r\n      return;\r\n    }\r\n    this.#state.isMoving = true;\r\n    const event = e.type.search('touch') === 0 ? e.changedTouches[0] : e;\r\n    let diffPosX = this.#state.swipeX - event.clientX;\r\n    const diffPosY = this.#state.swipeY - event.clientY;\r\n    const prevPosX = this.#state.prevPosX ? this.#state.prevPosX : event.clientX;\r\n    const direction = prevPosX > event.clientX ? 'next' : 'prev';\r\n    this.#state.prevPosX = event.clientX;\r\n    if (!this.#state.isTouchMoving) {\r\n      if (Math.abs(diffPosY) > Math.abs(diffPosX) || Math.abs(diffPosX) === 0) {\r\n        this.#state.isSwiping = false;\r\n        return;\r\n      }\r\n      this.#state.isTouchMoving = true;\r\n    }\r\n    e.preventDefault();\r\n    if (!this.#config.loop) {\r\n      const isNotMoveFirst = this.#state.activeItems[0] === 1 && diffPosX <= 0;\r\n      const isNotMoveLast =\r\n        this.#state.activeItems[this.#state.activeItems.length - 1] && diffPosX >= 0;\r\n      if (isNotMoveFirst || isNotMoveLast) {\r\n        diffPosX /= 4;\r\n      }\r\n    }\r\n    const transitionNoneClass = this.#state.prefix + this.constructor.#TRANSITION_NONE;\r\n    this.#state.elItems.classList.add(transitionNoneClass);\r\n    const translate = this.#state.translate - diffPosX;\r\n    this.#state.elItems.style.transform = `translate3D(${translate}px, 0px, 0.1px)`;\r\n    if (this.#config.loop) {\r\n      this.#state.direction = diffPosX > 0 ? 'next' : 'prev';\r\n      this.#state.direction = direction;\r\n      window.requestAnimationFrame(() => {\r\n        this.#balanceItems(true);\r\n      });\r\n    }\r\n  }\r\n\r\n  #attachEvents() {\r\n    this.#state.events = {\r\n      click: [this.#state.el, this.#onClick.bind(this), true],\r\n      mouseenter: [this.#state.el, this.#onMouseEnter.bind(this), true],\r\n      mouseleave: [this.#state.el, this.#onMouseLeave.bind(this), true],\r\n      transitionstart: [this.#state.elItems, this.#onTransitionStart.bind(this), this.#config.loop],\r\n      transitionend: [this.#state.elItems, this.#onTransitionEnd.bind(this), this.#config.loop],\r\n      touchstart: [this.#state.el, this.#touchStart.bind(this), this.#config.swipe],\r\n      mousedown: [this.#state.el, this.#touchStart.bind(this), this.#config.swipe],\r\n      touchend: [document, this.#touchEnd.bind(this), this.#config.swipe],\r\n      mouseup: [document, this.#touchEnd.bind(this), this.#config.swipe],\r\n      touchmove: [this.#state.el, this.#touchMove.bind(this), this.#config.swipe],\r\n      mousemove: [this.#state.el, this.#touchMove.bind(this), this.#config.swipe],\r\n      dragstart: [this.#state.el, this.#onDragStart.bind(this), true],\r\n      visibilitychange: [document, this.#onVisibilityChange.bind(this), true],\r\n    };\r\n    Object.keys(this.#state.events).forEach((type) => {\r\n      if (this.#state.events[type][2]) {\r\n        const el = this.#state.events[type][0];\r\n        const fn = this.#state.events[type][1];\r\n        if (type === 'touchstart' || type === 'touchmove') {\r\n          const options = this.constructor.checkSupportPassiveEvents() ? { passive: false } : false;\r\n          el.addEventListener(type, fn, options);\r\n        } else {\r\n          el.addEventListener(type, fn);\r\n        }\r\n      }\r\n    });\r\n    const resizeObserver = new ResizeObserver((entries) => {\r\n      window.requestAnimationFrame(this.#reset.bind(this));\r\n    });\r\n    resizeObserver.observe(this.#state.elWrapper);\r\n  }\r\n\r\n  #detachEvents() {\r\n    Object.keys(this.#state.events).forEach((type) => {\r\n      if (this.#state.events[type][2]) {\r\n        const el = this.#state.events[type][0];\r\n        const fn = this.#state.events[type][1];\r\n        el.removeEventListener(type, fn);\r\n      }\r\n    });\r\n  }\r\n\r\n  #autoplay(action) {\r\n    if (!this.#config.autoplay) {\r\n      return;\r\n    }\r\n    if (action === 'stop') {\r\n      clearInterval(this.#state.intervalId);\r\n      this.#state.intervalId = null;\r\n      return;\r\n    }\r\n    if (this.#state.intervalId === null) {\r\n      this.#state.intervalId = setInterval(() => {\r\n        this.#state.direction = this.#config.direction === 'prev' ? 'prev' : 'next';\r\n        this.#move();\r\n      }, this.#config.interval);\r\n    }\r\n  }\r\n\r\n  #balanceItems(once = false) {\r\n    if (!this.#state.isBalancing && !once) {\r\n      return;\r\n    }\r\n    const wrapperRect = this.#state.elWrapper.getBoundingClientRect();\r\n    const targetWidth = wrapperRect.width / this.#state.countActiveItems / 2;\r\n    const countItems = this.#state.elListItem.length;\r\n    if (this.#state.direction === 'next') {\r\n      const exItemRectRight = this.#state.exItemMin.getBoundingClientRect().right;\r\n      if (exItemRectRight < wrapperRect.left - targetWidth) {\r\n        const elFound = this.#state.els.find((item) => item.el === this.#state.exItemMin);\r\n        elFound.order = this.#state.exOrderMin + countItems;\r\n        const translate = this.#state.exTranslateMin + countItems * this.#state.width;\r\n        elFound.translate = translate;\r\n        this.#state.exItemMin.style.transform = `translate3D(${translate}px, 0px, 0.1px)`;\r\n        this.#updateExProperties();\r\n      }\r\n    } else {\r\n      const exItemRectLeft = this.#state.exItemMax.getBoundingClientRect().left;\r\n      if (exItemRectLeft > wrapperRect.right + targetWidth) {\r\n        const elFound = this.#state.els.find((item) => item.el === this.#state.exItemMax);\r\n        elFound.order = this.#state.exOrderMax - countItems;\r\n        const translate = this.#state.exTranslateMax - countItems * this.#state.width;\r\n        elFound.translate = translate;\r\n        this.#state.exItemMax.style.transform = `translate3D(${translate}px, 0px, 0.1px)`;\r\n        this.#updateExProperties();\r\n      }\r\n    }\r\n    if (!once) {\r\n      window.requestAnimationFrame(() => {\r\n        this.#balanceItems(false);\r\n      });\r\n    }\r\n  }\r\n\r\n  #updateClasses() {\r\n    const activeClass = this.#state.prefix + this.constructor.#EL_ITEM_ACTIVE;\r\n    this.#state.activeItems.forEach((item, index) => {\r\n      if (item) {\r\n        this.#state.elListItem[index].classList.add(activeClass);\r\n      } else {\r\n        this.#state.elListItem[index].classList.remove(activeClass);\r\n      }\r\n      const elListIndicators = this.#state.el.querySelectorAll(\r\n        `.${this.#state.prefix}${this.constructor.#EL_INDICATOR}`,\r\n      );\r\n      if (elListIndicators.length && item) {\r\n        elListIndicators[index].classList.add(\r\n          `${this.#state.prefix}${this.constructor.#EL_INDICATOR_ACTIVE}`,\r\n        );\r\n      } else if (elListIndicators.length && !item) {\r\n        elListIndicators[index].classList.remove(\r\n          `${this.#state.prefix}${this.constructor.#EL_INDICATOR_ACTIVE}`,\r\n        );\r\n      }\r\n    });\r\n  }\r\n\r\n  #move() {\r\n    if (this.#state.direction === 'none') {\r\n      const transform = this.#state.translate;\r\n      this.#state.elItems.style.transform = `translate3D(${transform}px, 0px, 0.1px)`;\r\n      return;\r\n    }\r\n    const widthItem = this.#state.direction === 'next' ? -this.#state.width : this.#state.width;\r\n    const transform = this.#state.translate + widthItem;\r\n    if (!this.#config.loop) {\r\n      const limit =\r\n        this.#state.width * (this.#state.elListItem.length - this.#state.countActiveItems);\r\n      if (transform < -limit || transform > 0) {\r\n        return;\r\n      }\r\n      if (this.#state.btnPrev) {\r\n        this.#state.btnPrev.classList.remove(this.#state.btnClassHide);\r\n        this.#state.btnNext.classList.remove(this.#state.btnClassHide);\r\n      }\r\n      if (this.#state.btnPrev && transform === -limit) {\r\n        this.#state.btnNext.classList.add(this.#state.btnClassHide);\r\n      } else if (this.#state.btnPrev && transform === 0) {\r\n        this.#state.btnPrev.classList.add(this.#state.btnClassHide);\r\n      }\r\n    }\r\n    if (this.#state.direction === 'next') {\r\n      this.#state.activeItems = [\r\n        ...this.#state.activeItems.slice(-1),\r\n        ...this.#state.activeItems.slice(0, -1),\r\n      ];\r\n    } else {\r\n      this.#state.activeItems = [\r\n        ...this.#state.activeItems.slice(1),\r\n        ...this.#state.activeItems.slice(0, 1),\r\n      ];\r\n    }\r\n    this.#updateClasses();\r\n    this.#state.translate = transform;\r\n    this.#state.elItems.style.transform = `translate3D(${transform}px, 0px, 0.1px)`;\r\n  }\r\n\r\n  #moveTo(index) {\r\n    const delta = this.#state.activeItems.reduce((acc, current, currentIndex) => {\r\n      const diff = current ? index - currentIndex : acc;\r\n      return Math.abs(diff) < Math.abs(acc) ? diff : acc;\r\n    }, this.#state.activeItems.length);\r\n    if (delta !== 0) {\r\n      this.#state.direction = delta > 0 ? 'next' : 'prev';\r\n      for (let i = 0; i < Math.abs(delta); i++) {\r\n        this.#move();\r\n      }\r\n    }\r\n  }\r\n\r\n  // приватный метод для выполнения первичной инициализации\r\n  #init() {\r\n    // состояние элементов\r\n    this.#state.els = [];\r\n    // текущее значение translate\r\n    this.#state.translate = 0;\r\n    // позиции активных элементов\r\n    this.#state.activeItems = [];\r\n    // состояние элементов\r\n    this.#state.isBalancing = false;\r\n    // получаем gap между слайдами\r\n    const gap = parseFloat(getComputedStyle(this.#state.elItems).gap) || 0;\r\n    // ширина одного слайда\r\n    this.#state.width = this.#state.elListItem[0].getBoundingClientRect().width + gap;\r\n    // ширина #EL_WRAPPER\r\n    const widthWrapper = this.#state.elWrapper.getBoundingClientRect().width;\r\n    // количество активных элементов\r\n    this.#state.countActiveItems = Math.round(widthWrapper / this.#state.width);\r\n    this.#state.elListItem.forEach((el, index) => {\r\n      el.style.transform = '';\r\n      this.#state.activeItems.push(index < this.#state.countActiveItems ? 1 : 0);\r\n      this.#state.els.push({\r\n        el,\r\n        index,\r\n        order: index,\r\n        translate: 0,\r\n      });\r\n    });\r\n    if (this.#config.loop) {\r\n      const lastIndex = this.#state.elListItem.length - 1;\r\n      const translate = -(lastIndex + 1) * this.#state.width;\r\n      this.#state.elListItem[lastIndex].style.transform = `translate3D(${translate}px, 0px, 0.1px)`;\r\n      this.#state.els[lastIndex].order = -1;\r\n      this.#state.els[lastIndex].translate = translate;\r\n      this.#updateExProperties();\r\n    } else if (this.#state.btnPrev) {\r\n      this.#state.btnPrev.classList.add(this.#state.btnClassHide);\r\n    }\r\n    this.#updateClasses();\r\n    this.#autoplay();\r\n  }\r\n\r\n  #reset() {\r\n    const transitionNoneClass = this.#state.prefix + this.constructor.#TRANSITION_NONE;\r\n    // получаем gap между слайдами\r\n    const gap = parseFloat(getComputedStyle(this.#state.elItems).gap) || 0;\r\n    // ширина одного слайда\r\n    const widthItem = this.#state.elListItem[0].getBoundingClientRect().width + gap;\r\n    const widthWrapper = this.#state.elWrapper.getBoundingClientRect().width;\r\n    const countActiveEls = Math.round(widthWrapper / widthItem);\r\n    if (widthItem === this.#state.width && countActiveEls === this.#state.countActiveItems) {\r\n      return;\r\n    }\r\n    this.#autoplay('stop');\r\n    this.#state.elItems.classList.add(transitionNoneClass);\r\n    this.#state.elItems.style.transform = 'translate3D(0px, 0px, 0.1px)';\r\n    this.#init();\r\n    window.requestAnimationFrame(() => {\r\n      this.#state.elItems.classList.remove(transitionNoneClass);\r\n    });\r\n  }\r\n\r\n  #updateExProperties() {\r\n    const els = this.#state.els.map((item) => item.el);\r\n    const orders = this.#state.els.map((item) => item.order);\r\n    this.#state.exOrderMin = Math.min(...orders);\r\n    this.#state.exOrderMax = Math.max(...orders);\r\n    const min = orders.indexOf(this.#state.exOrderMin);\r\n    const max = orders.indexOf(this.#state.exOrderMax);\r\n    this.#state.exItemMin = els[min];\r\n    this.#state.exItemMax = els[max];\r\n    this.#state.exTranslateMin = this.#state.els[min].translate;\r\n    this.#state.exTranslateMax = this.#state.els[max].translate;\r\n  }\r\n}\r\n\r\nItcSlider.createInstances();\r\n\n\n//# sourceURL=webpack://evclid-nav/./src/js/modules/slider.js?");

/***/ }),

/***/ "./src/js/modules/tabs.js":
/*!********************************!*\
  !*** ./src/js/modules/tabs.js ***!
  \********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\nclass ItcTabs {\n  constructor(target, config) {\n    const defaultConfig = {};\n    this._config = Object.assign(defaultConfig, config);\n    this._elTabs = typeof target === 'string' ? document.querySelector(target) : target;\n    this._elButtons = this._elTabs.querySelectorAll('.tabs__btn');\n    this._elPanes = this._elTabs.querySelectorAll('.tabs__pane');\n    this._eventShow = new Event('tab.itc.change');\n    this._init();\n    this._events();\n  }\n  _init() {\n    this._elTabs.setAttribute('role', 'tablist');\n    this._elButtons.forEach((el, index) => {\n      el.dataset.index = index;\n      el.setAttribute('role', 'tab');\n      this._elPanes[index].setAttribute('role', 'tabpanel');\n    });\n  }\n  show(elLinkTarget) {\n    const elPaneTarget = this._elPanes[elLinkTarget.dataset.index];\n    const elLinkActive = this._elTabs.querySelector('.tabs__btn_active');\n    const elPaneShow = this._elTabs.querySelector('.tabs__pane_show');\n    if (elLinkTarget === elLinkActive) {\n      return;\n    }\n    elLinkActive ? elLinkActive.classList.remove('tabs__btn_active') : null;\n    elPaneShow ? elPaneShow.classList.remove('tabs__pane_show') : null;\n    elLinkTarget.classList.add('tabs__btn_active');\n    elPaneTarget.classList.add('tabs__pane_show');\n    this._elTabs.dispatchEvent(this._eventShow);\n    elLinkTarget.focus();\n  }\n  showByIndex(index) {\n    const elLinkTarget = this._elButtons[index];\n    elLinkTarget ? this.show(elLinkTarget) : null;\n  }\n  _events() {\n    this._elTabs.addEventListener('click', (e) => {\n      const target = e.target.closest('.tabs__btn');\n      if (target) {\n        e.preventDefault();\n        this.show(target);\n      }\n    });\n  }\n}\nconst tabs = new ItcTabs('.tabs__container');\n\n\n//# sourceURL=webpack://evclid-nav/./src/js/modules/tabs.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/js/app.js");
/******/ 	
/******/ })()
;